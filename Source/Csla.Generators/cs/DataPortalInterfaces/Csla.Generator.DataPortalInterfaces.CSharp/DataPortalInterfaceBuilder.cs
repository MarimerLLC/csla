//-----------------------------------------------------------------------
// <copyright file="DataPortalInterfaceBuilder.cs" company="Marimer LLC">
//     Copyright (c) Marimer LLC. All rights reserved.
//     Website: https://cslanet.com
// </copyright>
// <summary>Builds generated source for data portal interface implementation</summary>
//-----------------------------------------------------------------------

using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Csla.Generator.DataPortalInterfaces.CSharp.Extractors;

namespace Csla.Generator.DataPortalInterfaces.CSharp
{

  /// <summary>
  /// Builds the generated source code that provides an explicit
  /// implementation of IDataPortalOperationMapping for a business type
  /// </summary>
  internal class DataPortalInterfaceBuilder
  {

    /// <summary>
    /// Build the partial type definition with the interface implementation
    /// </summary>
    internal GenerationResults BuildPartialTypeDefinition(ExtractedTypeDefinition typeDefinition)
    {
      using var stringWriter = new StringWriter();
      var textWriter = new IndentedTextWriter(stringWriter, "  ");

      textWriter.WriteLine("//<auto-generated/>");
      textWriter.WriteLine("#nullable enable");
      textWriter.WriteLine();

      AppendContainerDefinitions(textWriter, typeDefinition);
      AppendTypeDefinition(textWriter, typeDefinition);
      AppendBlockStart(textWriter);

      AppendInvokeOperationAsyncMethod(textWriter, typeDefinition);

      AppendBlockEnd(textWriter);
      AppendContainerDefinitionClosures(textWriter, typeDefinition);

      return new GenerationResults
      {
        FullyQualifiedName = typeDefinition.FullyQualifiedName,
        GeneratedSource = stringWriter.ToString()
      };
    }

    private void AppendBlockStart(IndentedTextWriter textWriter)
    {
      textWriter.WriteLine("{");
      textWriter.Indent++;
    }

    private void AppendBlockEnd(IndentedTextWriter textWriter)
    {
      textWriter.Indent--;
      textWriter.WriteLine("}");
    }

    private void AppendContainerDefinitions(IndentedTextWriter textWriter, ExtractedTypeDefinition typeDefinition)
    {
      foreach (var containerDefinition in typeDefinition.ContainerDefinitions)
      {
        textWriter.WriteLine(containerDefinition.FullDefinition);
        AppendBlockStart(textWriter);
      }
    }

    private void AppendContainerDefinitionClosures(IndentedTextWriter textWriter, ExtractedTypeDefinition typeDefinition)
    {
      foreach (var containerDefinition in typeDefinition.ContainerDefinitions)
      {
        AppendBlockEnd(textWriter);
      }
    }

    private void AppendTypeDefinition(IndentedTextWriter textWriter, ExtractedTypeDefinition typeDefinition)
    {
      textWriter.Write(typeDefinition.Scope);
      textWriter.Write(" partial class ");
      textWriter.Write(typeDefinition.TypeName);
      textWriter.Write(typeDefinition.TypeParameters);
      textWriter.WriteLine(" : Csla.Server.IDataPortalOperationMapping");
    }

    private void AppendInvokeOperationAsyncMethod(IndentedTextWriter textWriter, ExtractedTypeDefinition typeDefinition)
    {
      textWriter.WriteLine("async global::System.Threading.Tasks.Task Csla.Server.IDataPortalOperationMapping.InvokeOperationAsync(");
      textWriter.Indent++;
      textWriter.WriteLine("global::System.Type operationType, bool isSync, object?[]? criteria, global::System.IServiceProvider serviceProvider)");
      textWriter.Indent--;
      AppendBlockStart(textWriter);

      // Group methods by their operation attribute types
      var methodsByAttribute = GroupMethodsByAttribute(typeDefinition.OperationMethods);

      var isFirst = true;
      foreach (var group in methodsByAttribute)
      {
        if (isFirst)
        {
          textWriter.Write("if");
          isFirst = false;
        }
        else
        {
          textWriter.Write("else if");
        }

        textWriter.WriteLine($" (operationType == typeof({group.Key}))");
        AppendBlockStart(textWriter);

        foreach (var method in group.Value)
        {
          AppendMethodDispatch(textWriter, method);
        }

        AppendBlockEnd(textWriter);
      }

      textWriter.WriteLine("throw new Csla.Server.DataPortalOperationNotSupportedException(operationType, criteria);");

      AppendBlockEnd(textWriter);
    }

    private void AppendMethodDispatch(IndentedTextWriter textWriter, ExtractedOperationMethod method)
    {
      var criteriaCount = method.CriteriaParameters.Count;

      if (criteriaCount == 0)
      {
        textWriter.WriteLine("if (criteria is null or { Length: 0 })");
      }
      else
      {
        // Build pattern match: criteria is { Length: N } && criteria[0] is Type name && ...
        var conditions = new List<string>();
        conditions.Add($"criteria is {{ Length: {criteriaCount} }}");

        for (int i = 0; i < criteriaCount; i++)
        {
          var param = method.CriteriaParameters[i];
          conditions.Add($"criteria[{i}] is {param.TypeDisplayName} p{i}_{SanitizeTypeName(param.TypeFullName)}");
        }

        textWriter.WriteLine($"if ({string.Join(" && ", conditions)})");
      }

      AppendBlockStart(textWriter);

      // Resolve injected parameters
      foreach (var inject in method.InjectParameters)
      {
        if (inject.AllowNull)
        {
          textWriter.WriteLine($"var {inject.Name} = ({inject.TypeDisplayName}?)serviceProvider.GetService(typeof({inject.TypeDisplayName}));");
        }
        else
        {
          textWriter.WriteLine($"var {inject.Name} = ({inject.TypeDisplayName})(serviceProvider.GetService(typeof({inject.TypeDisplayName})) ?? throw new global::System.InvalidOperationException($\"No service for type '{{typeof({inject.TypeDisplayName})}}' has been registered.\"));");
        }
      }

      // Build method call
      var args = new List<string>();

      // All parameters in original order (criteria + inject interleaved)
      // We need to reconstruct the original parameter order
      // The criteria params are in order, inject params are in order
      // We emit them by building from both lists
      var allParams = GetAllParametersInOrder(method);
      foreach (var p in allParams)
      {
        if (p.IsInjected)
        {
          args.Add(p.Name);
        }
        else
        {
          var criteriaIndex = method.CriteriaParameters.IndexOf(p);
          args.Add($"p{criteriaIndex}_{SanitizeTypeName(p.TypeFullName)}");
        }
      }

      var argString = string.Join(", ", args);

      if (method.IsAsync)
      {
        textWriter.WriteLine($"await {method.MethodName}({argString}).ConfigureAwait(false);");
      }
      else
      {
        textWriter.WriteLine($"{method.MethodName}({argString});");
      }

      textWriter.WriteLine("return;");
      AppendBlockEnd(textWriter);
    }

    private static IList<ExtractedOperationParameter> GetAllParametersInOrder(ExtractedOperationMethod method)
    {
      // Return all parameters in their original declaration order
      // by merging criteria and inject lists
      var all = new List<ExtractedOperationParameter>();
      all.AddRange(method.CriteriaParameters);
      all.AddRange(method.InjectParameters);
      return all;
    }

    private static Dictionary<string, List<ExtractedOperationMethod>> GroupMethodsByAttribute(
      IList<ExtractedOperationMethod> methods)
    {
      var result = new Dictionary<string, List<ExtractedOperationMethod>>();

      foreach (var method in methods)
      {
        foreach (var attr in method.OperationAttributeNames)
        {
          if (!result.TryGetValue(attr, out var list))
          {
            list = new List<ExtractedOperationMethod>();
            result[attr] = list;
          }
          list.Add(method);
        }
      }

      return result;
    }

    private static string SanitizeTypeName(string typeName)
    {
      // Remove global:: prefix and dots, convert to safe identifier
      return typeName
        .Replace("global::", "")
        .Replace(".", "_")
        .Replace("<", "_")
        .Replace(">", "_")
        .Replace(",", "_")
        .Replace(" ", "")
        .Replace("?", "Nullable");
    }
  }
}
