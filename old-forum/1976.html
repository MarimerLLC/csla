<html><header><title>Generics &amp; Inheritance (again)</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Generics &amp; Inheritance (again)</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1976.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>CaymanIslandsCarpediem posted on Thursday, December 14, 2006</h2><P>I've been using CSLA 1.x for some time and am finally going to take the leap to 2.x.&nbsp; My biggest question (which seems the same can be said for many) is how to do inheritance chains with generics.&nbsp; I've read all the previous posts on the subject (a bit of information overload).&nbsp; </P>
<P>With all the talk in previous posts about using interfaces instead of inheritance I'll really quickly explain why I'm using inheritance.&nbsp; If anyone can explain how to use interfaces to accomplish this I'll be glad to try it.&nbsp;</P>
<P>First off, I'm using inheritance because of common data. I know, I'm bad <img src="/emoticons/emotion-14.gif" alt="Devil [6]" />!&nbsp; Its all supposed to be modeled on behaviour, but what can I say.&nbsp; Here is an example of why I'm using inheritance.&nbsp; I have many different objects which can all have n number of documents associated with them.&nbsp;&nbsp; I have a base&nbsp;class which has all the functionality for dealing with these documents and I then inherit from that base class so I get that document functionality for "free" (no real extra code in the child classes).&nbsp; I REALLY don't want to use an interface where I would then have to duplicate this basic document functionality (association and basic CRUD operations) in each&nbsp;class which implements that interface.<BR><BR>So thats the "why" (again would be happy to hear other options), now for the question of "how" in CSLA 2.x.&nbsp; Everything I've been reading here is that generics and inheritance just don't play nicely together.&nbsp; So my question is: if when I define the "base"&nbsp;class I make that a concrete type can I then just inherit the base&nbsp;class from the children?&nbsp; Will this cause any issues?&nbsp; <BR><BR>So if I define the base&nbsp;class as:<BR><BR>public abstract class BaseObject : BusinessBase&lt;BaseObject&gt;<BR><BR>Can I then define any/all levels of child objects the "old" way like:<BR><BR>public class ChildObject : BaseObject<BR><BR>And if I do go this route, am I giving anything up by not trying to use generics all the way through the inheritance chain?<BR><BR>Thx!</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, December 14, 2006</h2><P>&lt;insert rebuke about data-centric design here <img src="/emoticons/emotion-4.gif" alt="Stick out tongue [:P]" />&gt;</P>
<P>I think you'll be happiest if you create non-generic base classes as high in your inheritance hierarchy as possible and just live without generics for all your business classes. Otherwise could end up creating generic and non-generic version of each of your objects and that'd be a pain.</P>
<P>Product<BR>Product&lt;-ServiceProduct<BR>Product&lt;-TaxableProduct<BR>Product&lt;-ServiceProduct&lt;-TaxableService</P>
<P>You get something like that, where you really want to be able to instantiate any of those objects, but you also want the inheritance, and generics will seriously complicate matters.</P>
<P>You can create your own custom BusinessBase by inheriting directly from Csla.Core.BusinessBase - bypassing generics all the way down.</P>
<P>For collections and other base classes you'll probably have to start with a generic base class and create a non-generic subclass that will be your base class for all subsequent classes.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal replied on Thursday, December 14, 2006</h2>I guess it would really depend on what you have to do.<br>If you have a situation such as the one rocky mentions, it's going to be a pain with generics, since you can't make instances of generic classes. But if those base classes are not supposed to work in stand alone mode (meaning, create an instance of a base class), then definitely go with generics.<br><br>So, assuming that everything that is called "xyzBase" is not something that you will create an instance of and use it like a stand alone object, you should be good.<br><br>If you still need to make that Base class and be able to make an instance of it but don't want to loose the advantages of generics, it can be solved by having something like this:<br><br>Public Class ProductBase(Of T)<br>&nbsp;&nbsp;&nbsp; Inherits Csla.BusinessBase(Of T)<br>&lt;&lt;All the code here&gt;&gt;<br>End Class<br><br>Public Class Product<br>&nbsp;&nbsp;&nbsp; Inherits ProductBase(Of Product)<br>&lt;&lt; No Code Here other than the factory &gt;&gt;<br>&lt;&lt; methods and perhaps an override of GetIdValue() &gt;&gt;<br>End Class<br><br><br>That way, you have a generally inheritable generic class that you can use for pretty much anything you need, and another non-generic class with not really any code in it, other than the factory methods, that you can use in as a regular business object in your ui...<br><br><br>This is of course pointless if you need not to create an instance of product and you are only ever going to use it as a base class, in which case you don't need that second class at all and generics wouldn't ever get into your way...<br><br>Andrés</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>CaymanIslandsCarpediem replied on Thursday, December 14, 2006</h2><P>Thanks all, thats basically what I figured.&nbsp; Sounds like I should be able to not have any big issues in my case (my base class is abstract).&nbsp; Cheers!</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Michael Hildner replied on Thursday, December 14, 2006</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>CaymanIslandsCarpediem:</strong></div><div>I have many different objects which can all have n number of documents associated with them.&nbsp;&nbsp; I have a base&nbsp;class which has all the functionality for dealing with these documents and I then inherit from that base class so I get that document functionality for "free" (no real extra code in the child classes).&nbsp; I REALLY don't want to use an interface where I would then have to duplicate this basic document functionality (association and basic CRUD operations) in each&nbsp;class which implements that interface.</div></BLOCKQUOTE></P>
<P>Maybe I don't get it but why not have your objects have an instance variable/property that's a collection of documents? e.g. DocumentEditableChildList and DocumentEditableChild.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>CaymanIslandsCarpediem replied on Thursday, December 14, 2006</h2><P>Well, really I could.&nbsp; The biggest issue for me is its not just documents, but there are roughly 10 of these common data items hanging off the base class and there are roughly 20 objects which all need these common items.&nbsp; So I'd have to create all these properties as well other tasks (update calls, etc) in each child class.&nbsp; I'm not crazy about this from a maintance perspective with all the duplicated code.&nbsp; </P>
<P>However, I may still go that route.&nbsp; This question is really about "can" I do it this way (especially initially just to make the upgrade to smoother).&nbsp; Realisticly I may well do it with interfaces yet, I just wanted to make sure the inheritance option was open to me.&nbsp; With .NET partial classes and code generation I think I can just generate all of that logic so the duplication/maintance worries kind of go away.&nbsp; Really, I'm liking that idea and its my goal to get there I'm just not sure I'll do that as part of my inital upgrade to CSLA 2.x.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, December 15, 2006</h2><P>Just my two cents...</P>
<P>I use Generics EXTENSIVELY in my class libraries.&nbsp; I am true lover of the template design - maybe it's because I come from the C/C++ world originally&nbsp; (via fortran, <img src="/emoticons/emotion-41.gif" alt="Ick! [+o(]" />)&nbsp; Anyway, here's a couple of rules-of-thumb that I have adopted to help me keep the oft-chaotic world of Generics under control:</P>
<P>1. I never create a Generic interface.&nbsp; The reason? Because Generics are a total pain when it comes to determining an object's type in code.&nbsp; For instance, if you want to know if something is enumerable, you will want to use a condition such as: <CODE>if (myClass is IEnumerable)</CODE> and not: <CODE>if (myClass is IEnumerable&lt;T&gt;)</CODE>.&nbsp; Fact is that this will fail unless it is contained in a Generic class with type T defined.&nbsp; So, to eliminate this headache, any custom interface I create is non-generic.&nbsp; This means that any class, whether Generic or not, that implements the interface can be handled in a non-Generic way.</P>
<P>2. All of my Generic classes are marked as <CODE>abstract</CODE> (<CODE>MustInherit</CODE> in VB).&nbsp; The reason?&nbsp; For one, the class was created to be a base class, this just forces it to be.&nbsp; By marking a class abstract, it allows you to inherit from the class but still adhere to the implement interfaces rule.&nbsp; This is because abstract classes are considered in the same "family" as an interface in OOP.&nbsp; It's not concrete.</P>
<P>3. Only implement a class as a Generic if some property or method MUST have knowledge of the concrete class (derived class).&nbsp; This is the case with collections (where Generics are prevalent) because the base class methods either accept or return objects of a specific type.</P>
<P>Inheritance with Generics is really no different than inheritance without.&nbsp; What you need to decide is whether your derived class will also serve as a base class or if it is the concrete class.&nbsp; If it is the concrete class, then you'd use the approach Andrés described: <CODE>public MyClass : BaseClass&lt;MyClass&gt;</CODE> and the Generic chain is gone and hidden from this point forward.&nbsp; On the other hand, if you are creating a new class that you intend to also serve as a base class, just carry the Generic forward, e.g. <CODE>public MyBaseClass&lt;T&gt; : SomeOtherBaseClass&lt;T&gt;</CODE>.</P>
<P>I do this often.&nbsp; One example is my SelectableCollectionBase class which contains a collection of selectable items (implementing&nbsp;my ISelectable interface).&nbsp; The class is declared as:</P>
<P><CODE>public abstract class SelectableCollectionBase&lt;T, C&gt; : CslaBusinessListBase&lt;T, C&gt;<BR>&nbsp; where T : SelectableCollectionBase&lt;T, C&gt;<BR>&nbsp; where C : ISelectable<BR>{<BR>:<BR>} </CODE></P>
<P>In regards to your specific example, the question to ask yourself when determining if your "BaseObject" should be Generic or not is to see if you are accepting or returning any BaseObject arguments.&nbsp; If you are then you are setting yourself up to code in casting whenever you use those properties or methods.&nbsp; This is because you'll be passing in or want the return value to be in your concrete class, ChildObject, and the only way to do that is to cast it from BaseObject to ChildObject.&nbsp; If you want to eliminate this need, then make BaseObject Generic as well as these properties/methods will be strongly-typed to your ChildObject and no more casting.&nbsp; And, keep in mind that these may not be new properties/methods that you've implemented in BaseObject, but by defining the class non-generically, you've set all the Generic properties and methods in the base class(es) to BaseObject as well.</P>
<P>Which brings me to my last rule-of-thumb:</P>
<P>4. Never use a Generic class as a concrete class.&nbsp; This is just a preference and a way to evaluate what I am doing.&nbsp; This is also a hard one to adhere to as there are plenty of times when there is good reason to violate this rule, such as List&lt;T&gt; and Nullable&lt;T&gt; - which I do use often.&nbsp; But, when designing my applications, if I'm going to have to instantiate List&lt;MyObject&gt;, then I would rather create a MyObjectCollection class that inherits from BusinessListBase&lt;T, C&gt; and I am no longer instantiating a Generic class as a concrete class.</P>
<P>Anyway, these are just the rules I follow. Hopefully I've justified my thinking a little and along the way helped you understand how Generics fit into the spectrum.&nbsp; As I said, I make extensive use out of them as I see them as a powerful tool to help you build your object model.</P>
<P>HTH</P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
